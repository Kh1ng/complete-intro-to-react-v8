{"pageProps":{"post":{"attributes":{"description":""},"html":"<p>Let&#39;s write a second test for actually making a request with our custom hook, useBreedList. But we have a problem: we don&#39;t actually want to <code>fetch</code> from our API. This can be slow and cause unnecessary load on a server or unnecessary complexity of spinning up a testing API. We can instead mock the call. A mock is a fake implementation. We <em>could</em> write our own fake fetch but a good one already exists for Vitest called vitest-fetch-mock so let&#39;s install that. Run</p>\n<pre><code class=\"language-bash\">npm install -D vitest-fetch-mock@0.2.1\n</code></pre>\n<p>We now need to make it so Vitest implements this mock before we run our tests. We can make it run a set up script by putting this in our vite.config.js:</p>\n<pre><code class=\"language-javascript\">// inside &quot;test&quot;\nsetupFiles: [&quot;./setupVitest.js&quot;],\n</code></pre>\n<p>Then let&#39;s make a file in src called setupVitest.js.</p>\n<pre><code class=\"language-javascript\">import createFetchMock from &quot;vitest-fetch-mock&quot;;\nimport { vi } from &quot;vitest&quot;;\n\nconst fetchMock = createFetchMock(vi);\nfetchMock.enableMocks();\n</code></pre>\n<p>Easy, right? Now it will fake all calls to fetch and we can provide fake API responses. We could provide a whole fake implementation here but let&#39;s do it in the testing code itself. If I was doing a lot of fake API calls, I might generate an <a href=\"https://swagger.io/\">OpenAPI</a> spec and use that to generate a fake API but that&#39;s pretty advance. Start small and grow when you hit barriers.</p>\n<p>Okay, now go back to our useBreedList.test.js and add:</p>\n<pre><code class=\"language-javascript\">// grab waitFor\nimport { renderHook, waitFor } from &quot;@testing-library/react&quot;;\n\n// add at bottom\ntest(&quot;gives back breeds with an animal&quot;, async () =&gt; {\n  const breeds = [\n    &quot;Havanese&quot;,\n    &quot;Bichon Frise&quot;,\n    &quot;Poodle&quot;,\n    &quot;Maltese&quot;,\n    &quot;Golden Retriever&quot;,\n    &quot;Labrador&quot;,\n    &quot;Husky&quot;,\n  ];\n  fetch.mockResponseOnce(\n    JSON.stringify({\n      animal: &quot;dog&quot;,\n      breeds,\n    })\n  );\n  const { result } = renderHook(() =&gt; useBreedList(&quot;dog&quot;), {\n    wrapper: ({ children }) =&gt; (\n      &lt;QueryClientProvider client={queryClient}&gt;{children}&lt;/QueryClientProvider&gt;\n    ),\n  });\n\n  await waitFor(() =&gt; expect(result.current[1]).toBe(&quot;success&quot;));\n\n  const [breedList] = result.current;\n  expect(breedList).toEqual(breeds);\n});\n</code></pre>\n<p>The <code>waitFor</code> allows us to sit back and wait for all of React&#39;s machinery to churn through the updates, effects, etc. until our data is ready for us to check on. And that&#39;s it! In general you should mock API calls. It will make tests run much faster and save unnecessary load on an API.</p>\n","slug":"mocks","title":"Mocks","section":"Testing","icon":"vial","filePath":"/home/runner/work/complete-intro-to-react-v8/complete-intro-to-react-v8/lessons/15-testing/E-mocks.md","nextSlug":"/lessons/testing/snapshots","prevSlug":"/lessons/testing/testing-custom-hooks"}},"__N_SSG":true}